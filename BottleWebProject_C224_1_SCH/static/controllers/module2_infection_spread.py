import random
import copy
import json
from datetime import datetime

def initialize_grid(size):
    """
        Функция initialize_grid
        Используется для инициализации сетки размером n x n, где центральная ячейка заражена, 
        а остальные ячейки здоровы.

        Принимаемые поля (агрументы): 
        size - размер сетки, которая будет создана, имеет форму n x n.

        Возвращаемые поля:
        grid - двумерный список, представляющий сетку, в котором каждый элемент внешнего
        списка представляет строку сетки (всего n), которая состоит из n ячеек.
    """

    # Создание двумерной сетки размером n * n, где каждая ячейка представлена
    # словарём с ключами состояния клетки и счётчика времени.
    grid = [[{'state': 'H', 'timer': 0} for _ in range(size)] for _ in range(size)]

    # Вычисляется индекс центральной ячейки и устанавливается в состояние 'I' (заражённая) с таймером 0.
    center = size // 2
    grid[center][center] = {'state': 'I', 'timer': 0}

    # Возвращается инициализированная сетка.
    return grid


def grid_to_json(grid):
    """
        Функция grid_to_json
        Преобразует сетку в формат, совместимый с JSON, для передачи данных клиенту.

        Принимаемые поля (аргументы):
        grid - двумерный список, представляющий сетку.

        Возвращаемые поля:
        двумерный список, где каждая ячейка представлена словарём
        с ключами 'state' и 'timer', готовый для сериализации в JSON.
    """
    return [[{'state': cell['state'], 'timer': cell['timer']} for cell in row] for row in grid]


def is_all_healthy(grid, size):
    """
        Функция is_all_healthy
        Проверяет, являются ли все ячейки сетки здоровыми (в состоянии 'H').

        Принимаемые поля (аргументы): 
        grid - двумерный список, представляющий сетку, где каждая ячейка — словарь
        с ключами 'state' и 'timer'.
        size - размер сетки (n * n).

        Возвращаемые поля:
        True, если все ячейки здоровы, False в противном случае.
    """
    # Перебираются все строки сетки
    for i in range(size):
        # Перебираются все столбцы 
        for j in range(size):
            # Проверяется состояние текущей ячейки. Если оно не 'H' (здоровое),
            # возвращается False, указывая, что не все ячейки здоровы.
            if grid[i][j]['state'] != 'H':
                return False
    # Если все ячейки здоровы, возвращается True.
    return True


def simulate_step(grid, size):
    """
        Функция simulate_step
        Выполняет один шаг симуляции распространения инфекции, обновляя состояние сетки.

        Принимаемые поля (аргументы): 
        grid - двумерный список, представляющий текущую сетку, где каждая ячейка — словарь
        с ключами 'state' и 'timer'.
        size - размер сетки (n x n).

        Возвращаемые поля:
        new_grid - обновлённая сетка после одного шага симуляции, где ячейки могут изменить
        состояние и таймеры.
    """
    # Направления смещения для проверки соседних ячеек (вверх, вниз, влево, вправо).
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    # Копия исходной сетки, чтобы изменения не затрагивали оригинал.
    new_grid = copy.deepcopy(grid)

    # Перебираются все строки сетки
    for i in range(size):
        # Перебираются все столбцы сетки
        for j in range(size):
            # Проверяется, является ли текущая ячейка заражённой ('I').
            if grid[i][j]['state'] == 'I':
                # Если таймер заражённой ячейки достиг или превысил 6 шагов,
                # ячейка переходит в состояние 'R' и таймер сбрасывается.
                if grid[i][j]['timer'] >= 6:
                    new_grid[i][j]['state'] = 'R'
                    new_grid[i][j]['timer'] = 0
                else:
                    # Таймер заражённой ячейки увеличивается на 1.
                    new_grid[i][j]['timer'] += 1

                    # Перебираются все соседние ячейки, определённые направлениями.
                    for di, dj in directions:
                        # Вычисляются координаты соседней ячейки (ni, nj).
                        ni, nj = i + di, j + dj

                        # Проверяется, находится ли соседняя ячейка в пределах сетки
                        # и является ли она здоровой.
                        if 0 <= ni < size and 0 <= nj < size and grid[ni][nj]['state'] == 'H':
                            # С вероятностью 50% соседняя ячейка заражается, и её таймер сбрасывается.
                            if random.random() < 0.5:
                                new_grid[ni][nj]['state'] = 'I'
                                new_grid[ni][nj]['timer'] = 0

            # Проверяется, является ли текущая ячейка невосприимчивой.
            elif grid[i][j]['state'] == 'R':
                # Если таймер невосприимчивой ячейки достиг или превысил 3 шага,
                # ячейка переходит в состояние 'H' и таймер сбрасывается.
                if grid[i][j]['timer'] >= 3:
                    new_grid[i][j]['state'] = 'H'
                    new_grid[i][j]['timer'] = 0

                else:
                    # Таймер невосприимчивой ячейки увеличивается на 1.
                    new_grid[i][j]['timer'] += 1

    # Возвращается обновлённая сетка после одного шага симуляции.
    return new_grid

def simulate_all_steps(initial_grid, size, max_steps=100):
    """
        Функция simulate_all_steps
        Генерирует все шаги симуляции распространения инфекции до достижения максимального
        количества шагов или состояния, когда все ячейки здоровы.

        Принимаемые поля (аргументы):
        initial_grid - начальная двумерная сетка, где каждый элемент - список ячеек, каждая
        ячейка - словарь с ключами 'state' (строка: 'H', 'I', 'R') и 'timer' (целое число).
        size - размер сетки (целое число), определяющий количество строк и столбцов.
        max_steps - максимальное количество шагов симуляции (целое число, по умолчанию 100).

        Возвращаемые поля:
        steps - список всех шагов симуляции, каждый элемент - двумерный список ячеек
        (копия сетки на каждом шаге).
        final_grid - конечная сетка после выполнения всех шагов или достижения состояния
        всех здоровых ячеек.
        all_healthy - булево значение (True, если все ячейки в конечной сетке имеют 'state' 'H',
        иначе False).
    """

    # Создаётся список steps, содержащий исходную сетку как первый элемент.
    steps = [initial_grid]

    # Текущая сетка инициализируется копией исходной сетки.
    current_grid = initial_grid

    # Выполняется цикл до max_steps раз.
    for _ in range(max_steps):
        # Выполняется один шаг симуляции, обновляя текущую сетку.
        current_grid = simulate_step(current_grid, size)

        # Обновлённая сетка добавляется в список шагов.
        steps.append(current_grid)

        # Проверяется, являются ли все ячейки здоровыми. Если да, цикл прерывается.
        if is_all_healthy(current_grid, size):
            break
    # Проверяется состояние всех ячеек в конечной сетке и сохраняется результат
    # в переменную all_healthy (True, если все ячейки здоровы, иначе False).
    all_healthy = is_all_healthy(current_grid, size)

    # Кортеж из списка всех шагов, конечной сетки и флага all_healthy.
    return steps, current_grid, all_healthy


def save_grid_state(grid, step_count):
    """
        Функция save_grid_state
        Подготавливает данные сетки для сохранения в формате JSON с добавлением номера шага
        и временной метки.

        Принимаемые поля (аргументы):
        grid - двумерный список, где каждый элемент - список ячеек, каждая ячейка - словарь
        с ключами 'state' (строка: 'H', 'I', 'R') и 'timer' (целое число).
        step_count - текущий номер шага симуляции (целое число).

        Возвращаемые поля:
        result - строка в формате JSON, содержащая словарь с ключами 'grid' (двумерный список
        ячеек), 'step_count' (целое число) и 'timestamp' (строка в формате 'день.месяц.год часы:минуты:секунды').
    """

    # Сетка преобразуется в JSON-совместимый формат с помощью функции grid_to_json.
    grid_json = grid_to_json(grid)

    # Создаётся словарь, содержащий сетку, номер шага и временную метку в формате
    # 'день.месяц.год часы:минуты:секунды'.
    data = {
        'grid': grid_json,
        'step_count': step_count,
        'timestamp': datetime.now().strftime('%d.%m.%Y %H:%M:%S')
    }

    # Словарь сериализуется в строку JSON с отступами для читаемости.
    return json.dumps(data, indent=2)
